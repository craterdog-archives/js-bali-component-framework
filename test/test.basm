test/source/main.basm:

1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result



test/source/mainWithFinal.basm:

1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
JUMP ON INTERRUPT TO 1.1.FinalClause
JUMP ON ALL TO 1.Done

1.1.FinalClause:
SKIP INSTRUCTION

1.1.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
RETURN FROM INTERRUPT

1.Done:
RETURN FROM METHOD



test/source/mainWithExceptions.basm:

1.ThrowException:
LOAD LITERAL `1`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$type`
LOAD LITERAL `'whine'`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
STORE VARIABLE $exception
JUMP ON INTERRUPT TO ExceptionClauses
JUMP ON ALL TO 1.Done

1.ExceptionClauses:
SKIP INSTRUCTION

1.1.ExceptionClause:
STORE VARIABLE $error
LOAD LITERAL `1`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$type`
LOAD LITERAL `'bad'`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.1.ExceptionClauseNoMatch

1.1.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
RETURN FROM INTERRUPT

1.1.ExceptionClauseNoMatch:
LOAD VARIABLE $error

1.2.ExceptionClause:
STORE VARIABLE $error
LOAD LITERAL `1`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$type`
LOAD LITERAL `'horrid'`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.2.ExceptionClauseNoMatch

1.2.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
RETURN FROM INTERRUPT

1.2.ExceptionClauseNoMatch:
LOAD VARIABLE $error
RETURN FROM INTERRUPT

1.Done:
RETURN FROM METHOD



test/source/mainWithExceptionsAndFinal.basm:

1.ThrowException:
LOAD LITERAL `1`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$type`
LOAD LITERAL `'whine'`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
STORE VARIABLE $exception
JUMP ON INTERRUPT TO ExceptionClauses
JUMP ON INTERRUPT TO 1.3.FinalClause
JUMP ON ALL TO 1.Done

1.ExceptionClauses:
SKIP INSTRUCTION

1.1.ExceptionClause:
STORE VARIABLE $error
LOAD LITERAL `1`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$type`
LOAD LITERAL `'bad'`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.1.ExceptionClauseNoMatch

1.1.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
RETURN FROM INTERRUPT

1.1.ExceptionClauseNoMatch:
LOAD VARIABLE $error

1.2.ExceptionClause:
STORE VARIABLE $error
LOAD LITERAL `1`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$type`
LOAD LITERAL `'horrid'`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.2.ExceptionClauseNoMatch

1.2.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
RETURN FROM INTERRUPT

1.2.ExceptionClauseNoMatch:
LOAD VARIABLE $error
JUMP ON INTERRUPT TO 1.3.FinalClause
RETURN FROM INTERRUPT
JUMP ON ALL TO 1.Done

1.3.FinalClause:
SKIP INSTRUCTION

1.3.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
RETURN FROM INTERRUPT

1.Done:
RETURN FROM METHOD



test/source/evaluateExpression.basm:

1.EvaluateExpression:
LOAD LITERAL `2`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$foo`
LOAD VARIABLE $bar
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
LOAD LITERAL `$baz`
LOAD LITERAL `5`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
STORE VARIABLE $result

2.EvaluateExpression:
LOAD VARIABLE $variable
STORE VARIABLE $result

3.EvaluateExpression:
LOAD LITERAL `1`
INVOKE INTRINSIC array WITH ARGUMENT
LOAD LITERAL `13`
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
CALL METHOD isPrime WITH ARGUMENT
STORE VARIABLE $result

4.EvaluateExpression:
LOAD VARIABLE $a
LOAD VARIABLE $b
INVOKE INTRINSIC sum WITH 2 ARGUMENTS
LOAD VARIABLE $c
INVOKE INTRINSIC product WITH 2 ARGUMENTS
STORE VARIABLE $result

5.EvaluateExpression:
LOAD VARIABLE $reference
INVOKE INTRINSIC dereference WITH ARGUMENT
STORE VARIABLE $result

6.EvaluateExpression:
LOAD VARIABLE $customer
LOAD LITERAL `$order`
INVOKE INTRINSIC getValue WITH 2 ARGUMENTS
LOAD LITERAL `$item`
INVOKE INTRINSIC getValue WITH 2 ARGUMENTS
LOAD LITERAL `5`
INVOKE INTRINSIC getValue WITH 2 ARGUMENTS
STORE VARIABLE $result

7.EvaluateExpression:
LOAD VARIABLE $list
LOAD LITERAL `1`
INVOKE INTRINSIC array WITH ARGUMENT
LOAD VARIABLE $item
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
CALL METHOD addItem WITH 2 ARGUMENTS
STORE VARIABLE $result

8.EvaluateExpression:
LOAD LITERAL `23`
INVOKE INTRINSIC factorial WITH ARGUMENT
STORE VARIABLE $result

9.EvaluateExpression:
LOAD LITERAL `2`
LOAD LITERAL `8`
INVOKE INTRINSIC exponential WITH 2 ARGUMENTS
STORE VARIABLE $result

10.EvaluateExpression:
LOAD LITERAL `pi`
INVOKE INTRINSIC negative WITH ARGUMENT
STORE VARIABLE $result

11.EvaluateExpression:
LOAD LITERAL `5`
INVOKE INTRINSIC inverse WITH ARGUMENT
STORE VARIABLE $result

12.EvaluateExpression:
LOAD LITERAL `(3, 4i)`
INVOKE INTRINSIC conjugate WITH ARGUMENT
STORE VARIABLE $result

13.EvaluateExpression:
LOAD VARIABLE $x
LOAD VARIABLE $y
INVOKE INTRINSIC product WITH 2 ARGUMENTS
STORE VARIABLE $result

14.EvaluateExpression:
LOAD VARIABLE $a
LOAD VARIABLE $b
INVOKE INTRINSIC quotient WITH 2 ARGUMENTS
STORE VARIABLE $result

15.EvaluateExpression:
LOAD VARIABLE $c
LOAD VARIABLE $d
INVOKE INTRINSIC remainder WITH 2 ARGUMENTS
STORE VARIABLE $result

16.EvaluateExpression:
LOAD VARIABLE $x
LOAD VARIABLE $y
INVOKE INTRINSIC sum WITH 2 ARGUMENTS
STORE VARIABLE $result

17.EvaluateExpression:
LOAD VARIABLE $w
LOAD VARIABLE $z
INVOKE INTRINSIC difference WITH 2 ARGUMENTS
STORE VARIABLE $result

18.EvaluateExpression:
LOAD LITERAL `(3, 4i)`
INVOKE INTRINSIC magnitude WITH ARGUMENT
STORE VARIABLE $result

19.EvaluateExpression:
LOAD VARIABLE $a
LOAD VARIABLE $b
INVOKE INTRINSIC less WITH 2 ARGUMENTS
STORE VARIABLE $result

20.EvaluateExpression:
LOAD VARIABLE $c
LOAD VARIABLE $d
INVOKE INTRINSIC equal WITH 2 ARGUMENTS
STORE VARIABLE $result

21.EvaluateExpression:
LOAD VARIABLE $f
LOAD VARIABLE $g
INVOKE INTRINSIC more WITH 2 ARGUMENTS
STORE VARIABLE $result

22.EvaluateExpression:
LOAD VARIABLE $h
LOAD VARIABLE $j
INVOKE INTRINSIC is WITH 2 ARGUMENTS
STORE VARIABLE $result

23.EvaluateExpression:
LOAD VARIABLE $k
LOAD VARIABLE $m
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
STORE VARIABLE $result

24.EvaluateExpression:
LOAD VARIABLE $p
INVOKE INTRINSIC complement WITH ARGUMENT
STORE VARIABLE $result

25.EvaluateExpression:
LOAD VARIABLE $a
LOAD VARIABLE $b
INVOKE INTRINSIC and WITH 2 ARGUMENTS
STORE VARIABLE $result

26.EvaluateExpression:
LOAD VARIABLE $c
LOAD VARIABLE $d
INVOKE INTRINSIC sans WITH 2 ARGUMENTS
STORE VARIABLE $result

27.EvaluateExpression:
LOAD VARIABLE $f
LOAD VARIABLE $g
INVOKE INTRINSIC xor WITH 2 ARGUMENTS
STORE VARIABLE $result

28.EvaluateExpression:
LOAD VARIABLE $h
LOAD VARIABLE $j
INVOKE INTRINSIC or WITH 2 ARGUMENTS
STORE VARIABLE $result

29.EvaluateExpression:
LOAD VARIABLE $foo
LOAD LITERAL `5`
INVOKE INTRINSIC default WITH 2 ARGUMENTS
STORE VARIABLE $result



test/source/evaluateExpressionWithResult.basm:

1.EvaluateExpression:
LOAD VARIABLE $document
LOAD LITERAL `$customer`
INVOKE INTRINSIC getValue WITH 2 ARGUMENTS
LOAD LITERAL `$order`
INVOKE INTRINSIC getValue WITH 2 ARGUMENTS
LOAD LITERAL `3`
STORE VARIABLE $_index_2
STORE VARIABLE $_component_1
LOAD VARIABLE $_component_1
LOAD VARIABLE $_index_2
LOAD VARIABLE $_component_1
LOAD VARIABLE $_index_2
INVOKE INTRINSIC getValue WITH 2 ARGUMENTS
LOAD LITERAL `5`
INVOKE INTRINSIC sum WITH 2 ARGUMENTS
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS

2.EvaluateExpression:
LOAD VARIABLE $bar
STORE VARIABLE $foo

3.EvaluateExpression:
LOAD VARIABLE $color
LOAD LITERAL `$violet`
INVOKE INTRINSIC default WITH 2 ARGUMENTS
STORE VARIABLE $color

4.EvaluateExpression:
LOAD VARIABLE $count
LOAD LITERAL `2`
INVOKE INTRINSIC sum WITH 2 ARGUMENTS
STORE VARIABLE $count

5.EvaluateExpression:
LOAD VARIABLE $count
LOAD LITERAL `1`
INVOKE INTRINSIC difference WITH 2 ARGUMENTS
STORE VARIABLE $count

6.EvaluateExpression:
LOAD VARIABLE $double
LOAD LITERAL `2`
INVOKE INTRINSIC product WITH 2 ARGUMENTS
STORE VARIABLE $double

7.EvaluateExpression:
LOAD VARIABLE $half
LOAD LITERAL `2`
INVOKE INTRINSIC quotient WITH 2 ARGUMENTS
STORE VARIABLE $half

8.EvaluateExpression:
LOAD VARIABLE $remainder
LOAD LITERAL `13`
INVOKE INTRINSIC remainder WITH 2 ARGUMENTS
STORE VARIABLE $remainder

9.EvaluateExpression:
LOAD VARIABLE $exponential
LOAD VARIABLE $n
INVOKE INTRINSIC exponential WITH 2 ARGUMENTS
STORE VARIABLE $exponential

10.EvaluateExpression:
LOAD VARIABLE $and
LOAD LITERAL `'01011101'`
INVOKE INTRINSIC and WITH 2 ARGUMENTS
STORE VARIABLE $and

11.EvaluateExpression:
LOAD VARIABLE $sans
LOAD LITERAL `'01101001'`
INVOKE INTRINSIC sans WITH 2 ARGUMENTS
STORE VARIABLE $sans

12.EvaluateExpression:
LOAD VARIABLE $or
LOAD LITERAL `'11110000'`
INVOKE INTRINSIC or WITH 2 ARGUMENTS
STORE VARIABLE $or

13.EvaluateExpression:
LOAD VARIABLE $xor
LOAD LITERAL `'10010100'`
INVOKE INTRINSIC xor WITH 2 ARGUMENTS
STORE VARIABLE $xor



test/source/ifThen.basm:

1.IfThen:
SKIP INSTRUCTION

1.1.IfCondition:
LOAD LITERAL `true`
JUMP ON FALSE TO 1.EndIf

1.1.1.EvaluateExpression:
LOAD LITERAL `true`
STORE VARIABLE $result

1.EndIf:
RETURN FROM METHOD



test/source/ifThenElse.basm:

1.IfThen:
SKIP INSTRUCTION

1.1.IfCondition:
LOAD LITERAL `true`
JUMP ON FALSE TO 1.2.ElseClause

1.1.1.EvaluateExpression:
LOAD LITERAL `true`
STORE VARIABLE $result
JUMP ON ALL TO 1.EndIf

1.2.ElseClause:
SKIP INSTRUCTION

1.2.1.EvaluateExpression:
LOAD LITERAL `false`
STORE VARIABLE $result

1.EndIf:
RETURN FROM METHOD



test/source/ifThenElseIf.basm:

1.IfThen:
SKIP INSTRUCTION

1.1.IfCondition:
LOAD LITERAL `true`
JUMP ON FALSE TO 1.2IfCondition

1.1.1.EvaluateExpression:
LOAD LITERAL `true`
STORE VARIABLE $result
JUMP ON ALL TO 1.EndIf

1.2.IfCondition:
LOAD LITERAL `false`
JUMP ON FALSE TO 1.EndIf

1.2.1.EvaluateExpression:
LOAD LITERAL `false`
STORE VARIABLE $result

1.EndIf:
RETURN FROM METHOD



test/source/ifThenElseIfElse.basm:

1.IfThen:
SKIP INSTRUCTION

1.1.IfCondition:
LOAD LITERAL `true`
JUMP ON FALSE TO 1.2IfCondition

1.1.1.EvaluateExpression:
LOAD LITERAL `true`
STORE VARIABLE $result
JUMP ON ALL TO 1.EndIf

1.2.IfCondition:
LOAD LITERAL `false`
JUMP ON FALSE TO 1.3.ElseClause

1.2.1.EvaluateExpression:
LOAD LITERAL `false`
STORE VARIABLE $result
JUMP ON ALL TO 1.EndIf

1.3.ElseClause:
SKIP INSTRUCTION

1.3.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result

1.EndIf:
RETURN FROM METHOD



test/source/selectOption.basm:

1.SelectFrom:
LOAD LITERAL `$selection`
STORE VARIABLE $_selection_1

1.1.SelectOption:
LOAD VARIABLE $_selection_1
LOAD LITERAL `'alpha'`
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.2SelectOption

1.1.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
JUMP ON ALL TO 1.EndSelect

1.2.SelectOption:
LOAD VARIABLE $_selection_1
LOAD LITERAL `'beta'`
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.3SelectOption

1.2.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
JUMP ON ALL TO 1.EndSelect

1.3.SelectOption:
LOAD VARIABLE $_selection_1
LOAD LITERAL `'gamma'`
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.EndSelect

1.3.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result

1.EndSelect:
RETURN FROM METHOD



test/source/selectOptionElse.basm:

1.SelectFrom:
LOAD LITERAL `$selection`
STORE VARIABLE $_selection_1

1.1.SelectOption:
LOAD VARIABLE $_selection_1
LOAD LITERAL `'alpha'`
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.2SelectOption

1.1.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
JUMP ON ALL TO 1.EndSelect

1.2.SelectOption:
LOAD VARIABLE $_selection_1
LOAD LITERAL `'beta'`
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.3SelectOption

1.2.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
JUMP ON ALL TO 1.EndSelect

1.3.SelectOption:
LOAD VARIABLE $_selection_1
LOAD LITERAL `'gamma'`
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.4.ElseClause

1.3.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
JUMP ON ALL TO 1.EndSelect

1.4.ElseClause:
SKIP INSTRUCTION

1.4.1.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result

1.EndSelect:
RETURN FROM METHOD



test/source/whileLoop.basm:

1.WhileLoop:
LOAD LITERAL `true`
STORE VARIABLE $_continue_1_1_WhileCondition

1.1.WhileCondition:
LOAD VARIABLE $_continue_1_1_WhileCondition
LOAD LITERAL `$condition`
INVOKE INTRINSIC and WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.EndWhile

1.1.1.EvaluateExpression:
LOAD LITERAL `true`
STORE VARIABLE $result

1.1.2.BreakFrom:
LOAD LITERAL `false`
STORE VARIABLE $_continue_1_1_WhileCondition
JUMP ON ALL TO 1.EndWhile

1.1.3.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
JUMP ON ALL TO 1.1.WhileCondition

1.EndWhile:
RETURN FROM METHOD



test/source/whileLoopWithLabel.basm:

1.WhileLoop:
LOAD LITERAL `true`
STORE VARIABLE $_continue_1_1_Label

1.1.Label:
LOAD VARIABLE $_continue_1_1_Label
LOAD LITERAL `$condition`
INVOKE INTRINSIC and WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.EndWhile

1.1.1.EvaluateExpression:
LOAD LITERAL `true`
STORE VARIABLE $result

1.1.2.ContinueTo:
JUMP ON ALL TO 1.EndWhile

1.1.3.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
JUMP ON ALL TO 1.1.Label

1.EndWhile:
RETURN FROM METHOD



test/source/withLoop.basm:

1.WithLoop:
LOAD LITERAL `$sequence`
CALL METHOD $createIterator WITH ARGUMENT
STORE VARIABLE $_iterator_1
LOAD LITERAL `true`
STORE VARIABLE $_continue_1_1_WithItem

1.1.WithItem:
LOAD VARIABLE $_continue_1_1_WithItem
LOAD VARIABLE $_iterator_1
CALL METHOD $hasNext WITH ARGUMENT
INVOKE INTRINSIC and WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.EndWith
LOAD VARIABLE $_iterator_1
CALL METHOD $getNext WITH ARGUMENT
STORE VARIABLE $_item_2

1.1.1.EvaluateExpression:
LOAD LITERAL `true`
STORE VARIABLE $result

1.1.2.ContinueTo:
JUMP ON ALL TO 1.EndWith

1.1.3.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
JUMP ON ALL TO 1.1.WithItem

1.EndWith:
RETURN FROM METHOD



test/source/withLoopWithLabel.basm:

1.WithLoop:
LOAD LITERAL `$sequence`
CALL METHOD $createIterator WITH ARGUMENT
STORE VARIABLE $_iterator_1
LOAD LITERAL `true`
STORE VARIABLE $_continue_1_1_Label

1.1.Label:
LOAD VARIABLE $_continue_1_1_Label
LOAD VARIABLE $_iterator_1
CALL METHOD $hasNext WITH ARGUMENT
INVOKE INTRINSIC and WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.EndWith
LOAD VARIABLE $_iterator_1
CALL METHOD $getNext WITH ARGUMENT
STORE VARIABLE $_item_2

1.1.1.EvaluateExpression:
LOAD LITERAL `true`
STORE VARIABLE $result

1.1.2.BreakFrom:
LOAD LITERAL `false`
STORE VARIABLE $_continue_1_1_Label
JUMP ON ALL TO 1.EndWith

1.1.3.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
JUMP ON ALL TO 1.1.Label

1.EndWith:
RETURN FROM METHOD



test/source/withEachLoop.basm:

1.WithLoop:
LOAD LITERAL `$sequence`
CALL METHOD $createIterator WITH ARGUMENT
STORE VARIABLE $_iterator_1
LOAD LITERAL `true`
STORE VARIABLE $_continue_1_1_WithItem

1.1.WithItem:
LOAD VARIABLE $_continue_1_1_WithItem
LOAD VARIABLE $_iterator_1
CALL METHOD $hasNext WITH ARGUMENT
INVOKE INTRINSIC and WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.EndWith
LOAD VARIABLE $_iterator_1
CALL METHOD $getNext WITH ARGUMENT
STORE VARIABLE $symbol

1.1.1.EvaluateExpression:
LOAD LITERAL `true`
STORE VARIABLE $result

1.1.2.ContinueTo:
JUMP ON ALL TO 1.EndWith

1.1.3.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
JUMP ON ALL TO 1.1.WithItem

1.EndWith:
RETURN FROM METHOD



test/source/withEachLoopWithLabel.basm:

1.WithLoop:
LOAD LITERAL `$sequence`
CALL METHOD $createIterator WITH ARGUMENT
STORE VARIABLE $_iterator_1
LOAD LITERAL `true`
STORE VARIABLE $_continue_1_1_Label

1.1.Label:
LOAD VARIABLE $_continue_1_1_Label
LOAD VARIABLE $_iterator_1
CALL METHOD $hasNext WITH ARGUMENT
INVOKE INTRINSIC and WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.EndWith
LOAD VARIABLE $_iterator_1
CALL METHOD $getNext WITH ARGUMENT
STORE VARIABLE $symbol

1.1.1.EvaluateExpression:
LOAD LITERAL `true`
STORE VARIABLE $result

1.1.2.BreakFrom:
LOAD LITERAL `false`
STORE VARIABLE $_continue_1_1_Label
JUMP ON ALL TO 1.EndWith

1.1.3.EvaluateExpression:
LOAD LITERAL `none`
STORE VARIABLE $result
JUMP ON ALL TO 1.1.Label

1.EndWith:
RETURN FROM METHOD



test/source/queueMessage.basm:

1.QueueMessage:
LOAD LITERAL `2`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$foo`
LOAD VARIABLE $bar
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
LOAD LITERAL `$baz`
LOAD LITERAL `5`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
CALL METHOD doSomething WITH 2 ARGUMENTS
INVOKE INTRINSIC message WITH 2 ARGUMENTS
LOAD LITERAL `#MJ0YKAX450LD84TCFJ7CNJ5CX8ZAPZ1Q`
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS



test/source/waitForMessage.basm:

1.WaitForMessage:
LOAD LITERAL `#MJ0YKAX450LD84TCFJ7CNJ5CX8ZAPZ1Q`
INVOKE INTRINSIC removeItem WITH ARGUMENT
STORE VARIABLE $message



test/source/publishEvent.basm:

1.PublishEvent:
LOAD LITERAL `3`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$type`
LOAD LITERAL `$changeEvent`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
LOAD LITERAL `$key`
LOAD LITERAL `$foo`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
LOAD LITERAL `$value`
LOAD LITERAL `5`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
INVOKE INTRINSIC queueEvent WITH ARGUMENT



test/source/comprehensive.basm:

1.IfThen:
SKIP INSTRUCTION

1.1.IfCondition:
LOAD VARIABLE $a
LOAD VARIABLE $b
INVOKE INTRINSIC less WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.2IfCondition

1.1.1.EvaluateExpression:
LOAD VARIABLE $b
STORE VARIABLE $a

1.1.2.EvaluateExpression:
LOAD VARIABLE $b
LOAD VARIABLE $c
INVOKE INTRINSIC sum WITH 2 ARGUMENTS
STORE VARIABLE $b

1.1.3.ThrowException:
LOAD VARIABLE $exception
STORE VARIABLE $exception
JUMP ON INTERRUPT TO ExceptionClauses
JUMP ON ALL TO 1.EndIf

1.2.IfCondition:
LOAD VARIABLE $a
LOAD LITERAL `0`
INVOKE INTRINSIC more WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.3.ElseClause

1.2.1.EvaluateExpression:
LOAD LITERAL `false`
STORE VARIABLE $result

1.2.2.EvaluateExpression:
LOAD LITERAL `1`
INVOKE INTRINSIC array WITH ARGUMENT
LOAD VARIABLE $b
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
CALL METHOD fibonacci WITH ARGUMENT
STORE VARIABLE $c

1.2.3.ReturnResult:
LOAD VARIABLE $c
STORE VARIABLE $result
RETURN FROM INTERRUPT
JUMP ON ALL TO 1.EndIf

1.3.ElseClause:
SKIP INSTRUCTION

1.3.1.EvaluateExpression:
LOAD VARIABLE $b
LOAD LITERAL `1`
INVOKE INTRINSIC array WITH ARGUMENT
LOAD LITERAL `$tag`
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
CALL METHOD find WITH 2 ARGUMENTS
STORE VARIABLE $d

1.3.2.EvaluateExpression:
LOAD LITERAL `(3, 4i)`
STORE VARIABLE $result

1.3.3.ReturnResult:
RETURN FROM INTERRUPT

1.EndIf:
JUMP ON INTERRUPT TO 1.6.FinalClause
JUMP ON ALL TO 1.Done

1.ExceptionClauses:
SKIP INSTRUCTION

1.4.ExceptionClause:
STORE VARIABLE $exception
LOAD LITERAL `1`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$type`
LOAD LITERAL `$warning`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.4.ExceptionClauseNoMatch

1.4.1.EvaluateExpression:
LOAD VARIABLE $count
LOAD LITERAL `1`
INVOKE INTRINSIC sum WITH 2 ARGUMENTS
STORE VARIABLE $count

1.4.2.EvaluateExpression:
LOAD LITERAL `2`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$message`
LOAD LITERAL `"Something not too serious happened."`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
LOAD LITERAL `$exception`
LOAD VARIABLE $exception
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
STORE VARIABLE $result
RETURN FROM INTERRUPT

1.4.ExceptionClauseNoMatch:
LOAD VARIABLE $exception

1.5.ExceptionClause:
STORE VARIABLE $exception
LOAD LITERAL `1`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$type`
LOAD LITERAL `$moderate`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 1.5.ExceptionClauseNoMatch

1.5.1.EvaluateExpression:
LOAD LITERAL `2`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$message`
LOAD LITERAL `"Something serious happened."`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
LOAD LITERAL `$exception`
LOAD VARIABLE $exception
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
STORE VARIABLE $exception

1.5.2.ThrowException:
LOAD VARIABLE $exception
STORE VARIABLE $exception
JUMP ON INTERRUPT TO ExceptionClauses
RETURN FROM INTERRUPT

1.5.ExceptionClauseNoMatch:
LOAD VARIABLE $exception
JUMP ON INTERRUPT TO 1.6.FinalClause
RETURN FROM INTERRUPT
JUMP ON ALL TO 1.Done

1.6.FinalClause:
SKIP INSTRUCTION

1.6.1.QueueMessage:
LOAD LITERAL `4`
INVOKE INTRINSIC array WITH ARGUMENT
LOAD VARIABLE $foo
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
LOAD VARIABLE $bar
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
LOAD VARIABLE $baz
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
LOAD LITERAL `5`
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
CALL METHOD wakeUp WITH 2 ARGUMENTS
INVOKE INTRINSIC message WITH 2 ARGUMENTS
LOAD LITERAL `#RSTMWSC0HFY00QJP37QD3JA533NLKPP5`
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS

1.6.2.PublishEvent:
LOAD LITERAL `2`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$type`
LOAD LITERAL `$confirmation`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
LOAD LITERAL `$timestamp`
CALL METHOD now WITH ARGUMENT
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
INVOKE INTRINSIC queueEvent WITH ARGUMENT
RETURN FROM INTERRUPT

1.Done:
SKIP INSTRUCTION

2.WhileLoop:
LOAD LITERAL `true`
STORE VARIABLE $_continue_2_1_Outer

2.1.Outer:
LOAD VARIABLE $_continue_2_1_Outer
LOAD LITERAL `true`
INVOKE INTRINSIC and WITH 2 ARGUMENTS
JUMP ON FALSE TO 2.EndWhile

2.1.1.EvaluateExpression:
LOAD VARIABLE $bar
STORE VARIABLE $foo

2.1.2.IfThen:
SKIP INSTRUCTION

2.1.2.1.IfCondition:
LOAD VARIABLE $foo
JUMP ON FALSE TO 2.1.2.2.ElseClause

2.1.2.1.1.BreakFrom:
LOAD LITERAL `false`
STORE VARIABLE $_continue_2_1_Outer
JUMP ON ALL TO 2.1.2.EndIf
JUMP ON ALL TO 2.1.2.EndIf

2.1.2.2.ElseClause:
SKIP INSTRUCTION

2.1.2.2.1.WithLoop:
LOAD VARIABLE $sequence
CALL METHOD $createIterator WITH ARGUMENT
STORE VARIABLE $_iterator_21
LOAD LITERAL `true`
STORE VARIABLE $_continue_2_1_2_2_1_1_WithItem

2.1.2.2.1.1.WithItem:
LOAD VARIABLE $_continue_2_1_2_2_1_1_WithItem
LOAD VARIABLE $_iterator_21
CALL METHOD $hasNext WITH ARGUMENT
INVOKE INTRINSIC and WITH 2 ARGUMENTS
JUMP ON FALSE TO 2.1.2.2.1.EndWith
LOAD VARIABLE $_iterator_21
CALL METHOD $getNext WITH ARGUMENT
STORE VARIABLE $item

2.1.2.2.1.1.1.SelectFrom:
LOAD VARIABLE $selection
STORE VARIABLE $_selection_22

2.1.2.2.1.1.1.1.SelectOption:
LOAD VARIABLE $_selection_22
LOAD LITERAL `$first`
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 2.1.2.2.1.1.1.2SelectOption

2.1.2.2.1.1.1.1.1.EvaluateExpression:
LOAD LITERAL `true`
STORE VARIABLE $result
JUMP ON ALL TO 2.1.2.2.1.1.1.EndSelect

2.1.2.2.1.1.1.2.SelectOption:
LOAD VARIABLE $_selection_22
LOAD LITERAL `$second`
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
JUMP ON FALSE TO 2.1.2.2.1.1.1.3.ElseClause

2.1.2.2.1.1.1.2.1.EvaluateExpression:
LOAD LITERAL `false`
STORE VARIABLE $result
JUMP ON ALL TO 2.1.2.2.1.1.1.EndSelect

2.1.2.2.1.1.1.3.ElseClause:
SKIP INSTRUCTION

2.1.2.2.1.1.1.3.1.ContinueTo:
LOAD LITERAL `false`
STORE VARIABLE $_continue_2_1_2_2_1_1_WithItem
JUMP ON ALL TO 2.1.2.2.1.1.1.EndSelect

2.1.2.2.1.1.1.EndSelect:
JUMP ON INTERRUPT TO 2.1.2.2.1.1.1.4.FinalClause
JUMP ON ALL TO 2.1.2.2.1.1.1.Done

2.1.2.2.1.1.1.4.FinalClause:
SKIP INSTRUCTION

2.1.2.2.1.1.1.4.1.EvaluateExpression:
LOAD LITERAL `$selectDone`
STORE VARIABLE $result
RETURN FROM INTERRUPT

2.1.2.2.1.1.1.Done:
JUMP ON ALL TO 2.1.2.2.1.1.WithItem

2.1.2.2.1.EndWith:
JUMP ON INTERRUPT TO 2.1.2.2.1.2.FinalClause
JUMP ON ALL TO 2.1.2.2.1.Done

2.1.2.2.1.2.FinalClause:
SKIP INSTRUCTION

2.1.2.2.1.2.1.EvaluateExpression:
LOAD LITERAL `$innerDone`
STORE VARIABLE $result
RETURN FROM INTERRUPT

2.1.2.2.1.Done:
SKIP INSTRUCTION

2.1.2.EndIf:
JUMP ON INTERRUPT TO 2.1.2.3.FinalClause
JUMP ON ALL TO 2.1.2.Done

2.1.2.3.FinalClause:
SKIP INSTRUCTION

2.1.2.3.1.EvaluateExpression:
LOAD LITERAL `$ifDone`
STORE VARIABLE $result
RETURN FROM INTERRUPT

2.1.2.Done:
JUMP ON ALL TO 2.1.Outer

2.EndWhile:
JUMP ON INTERRUPT TO 2.2.FinalClause
JUMP ON ALL TO 2.Done

2.2.FinalClause:
SKIP INSTRUCTION

2.2.1.EvaluateExpression:
LOAD LITERAL `$outerDone`
STORE VARIABLE $result
RETURN FROM INTERRUPT

2.Done:
RETURN FROM METHOD

