
1.IfThen:
SKIP INSTRUCTION

1.1.IfCondition:
LOAD VARIABLE $a
LOAD VARIABLE $b
INVOKE INTRINSIC less WITH 2 ARGUMENTS
BRANCH TO 1.2IfCondition ON NOT TRUE

1.1.1.EvaluateExpression:
LOAD VARIABLE $b
STORE VARIABLE $a

1.1.2.EvaluateExpression:
LOAD VARIABLE $b
LOAD VARIABLE $c
INVOKE INTRINSIC sum WITH 2 ARGUMENTS
STORE VARIABLE $b

1.1.3.ThrowException:
LOAD VARIABLE $exception
JUMP TO HANDLER ExceptionClauses
JUMP TO INSTRUCTION 1.EndIf

1.2.IfCondition:
LOAD VARIABLE $a
LOAD LITERAL `0`
INVOKE INTRINSIC more WITH 2 ARGUMENTS
BRANCH TO 1.3.ElseClause ON NOT TRUE

1.2.1.EvaluateExpression:
LOAD LITERAL `false`
STORE VARIABLE $result

1.2.2.EvaluateExpression:
LOAD LITERAL `1`
INVOKE INTRINSIC array WITH ARGUMENT
LOAD VARIABLE $b
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
CALL METHOD fibonacci WITH ARGUMENT
STORE VARIABLE $c

1.2.3.ReturnResult:
LOAD VARIABLE $c
RETURN FROM METHOD
JUMP TO INSTRUCTION 1.EndIf

1.3.ElseClause:
SKIP INSTRUCTION

1.3.1.EvaluateExpression:
LOAD VARIABLE $b
LOAD LITERAL `1`
INVOKE INTRINSIC array WITH ARGUMENT
LOAD LITERAL `$tag`
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
CALL METHOD find WITH 2 ARGUMENTS
STORE VARIABLE $d

1.3.2.EvaluateExpression:
LOAD LITERAL `(3, 4i)`
STORE VARIABLE $result

1.3.3.ReturnResult:
RETURN FROM METHOD

1.EndIf:
JUMP TO BLOCK 1.6.FinalClause
JUMP TO INSTRUCTION 1.Done

1.ExceptionClauses:
SKIP INSTRUCTION

1.4.ExceptionClause:
STORE VARIABLE $exception
LOAD LITERAL `1`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$type`
LOAD LITERAL `$warning`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
BRANCH TO 1.4.ExceptionClauseNoMatch ON NOT TRUE

1.4.1.EvaluateExpression:
LOAD VARIABLE $count
LOAD LITERAL `1`
INVOKE INTRINSIC sum WITH 2 ARGUMENTS
STORE VARIABLE $count

1.4.2.EvaluateExpression:
LOAD LITERAL `2`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$message`
LOAD LITERAL `"Something not too serious happened."`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
LOAD LITERAL `$exception`
LOAD VARIABLE $exception
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
STORE VARIABLE $result
RETURN FROM HANDLER

1.4.ExceptionClauseNoMatch:
LOAD VARIABLE $exception

1.5.ExceptionClause:
STORE VARIABLE $exception
LOAD LITERAL `1`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$type`
LOAD LITERAL `$moderate`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
INVOKE INTRINSIC matches WITH 2 ARGUMENTS
BRANCH TO 1.5.ExceptionClauseNoMatch ON NOT TRUE

1.5.1.EvaluateExpression:
LOAD LITERAL `2`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$message`
LOAD LITERAL `"Something serious happened."`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
LOAD LITERAL `$exception`
LOAD VARIABLE $exception
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
STORE VARIABLE $exception

1.5.2.ThrowException:
LOAD VARIABLE $exception
JUMP TO HANDLER ExceptionClauses
RETURN FROM HANDLER

1.5.ExceptionClauseNoMatch:
LOAD VARIABLE $exception
JUMP TO BLOCK 1.6.FinalClause
RETURN FROM EXCEPTION
JUMP TO INSTRUCTION 1.Done

1.6.FinalClause:
SKIP INSTRUCTION

1.6.1.QueueMessage:
LOAD LITERAL `4`
INVOKE INTRINSIC array WITH ARGUMENT
LOAD VARIABLE $foo
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
LOAD VARIABLE $bar
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
LOAD VARIABLE $baz
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
LOAD LITERAL `5`
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS
CALL METHOD wakeUp WITH 2 ARGUMENTS
INVOKE INTRINSIC message WITH 2 ARGUMENTS
LOAD LITERAL `#RSTMWSC0HFY00QJP37QD3JA533NLKPP5`
INVOKE INTRINSIC addItem WITH 2 ARGUMENTS

1.6.2.PublishEvent:
LOAD LITERAL `2`
INVOKE INTRINSIC table WITH ARGUMENT
LOAD LITERAL `$type`
LOAD LITERAL `$confirmation`
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
LOAD LITERAL `$timestamp`
CALL METHOD now WITH ARGUMENT
INVOKE INTRINSIC setValue WITH 3 ARGUMENTS
INVOKE INTRINSIC queueEvent WITH ARGUMENT
RETURN FROM BLOCK

1.Done:
SKIP INSTRUCTION

